#include <bits/stdc++.h>
using namespace std;
#define rep(i,n) for(int i=0; i<(int)(n); i++)

int main(){
  string S,T;
  cin >> S >> T;
  int L = S.size();
  bool ans = true;

  vector<int> S2T(26,-1),T2S(26,-1);
  // SとTの相互の変換を示すフラグ。
  // ex.) S2T[3]=5 のときは 「Sの'c'」が「Tの'e'」に対応するイメージ
  int a,b;
  for(int i=0; i<L; i++){
    a = S[i]-'a';
    b = T[i]-'a';
    if(S2T[a]!=-1 || T2S[b]!=-1){
      if(S2T[a]!=b || T2S[b]!=a){
        // もう既に別の置換組み合わせが設定されていた場合
        ans = false;
        break;
      }
    }
    // まだ置換表に書き込まれていない(-1のままだった)とき、書き込む
    S2T[a] = b;
    T2S[b] = a;
  }

  //すべての置換がうまく行っていればans=trueのママ抜け出せる
  cout << (ans ? "Yes" : "No") << endl;

}

/*
出てくる順と文字の組(文字自体は違っても良い)っていうのはなんとなくわかったけど
何すればいいかわからんから解説読んだ

S_a=S_b => T_a=T_b
T_a=T_b => S_a=S_b
が全てで成り立てば出てくる文字の順序組は等しいことが言える
(片方だけだと反例でTの文字列がすべてaaaaaaaみたいに同一の時も成り立ってしまう)
とりあえず愚直に実装。
時間オーダーはO(2*S^2)
|S|<2e5…ギリギリ間に合うか？
-> だめでした

ひらめいたのでやってみるやつ。
S,Tのそれぞれを頭から読み出して違う文字が出る度に順にa,b,c,... と変換していって
最終的な文字列が同じになれば？
と思ったが"abcdea"とか来たときに2回目以降のaをどう処理しよう…
→結局文字種類の被りを辞書使うとしてもO(S)かかるので実質O(S^2)と変わらないことに気付いた、ボツ

解説読んでもいまいちわからんので解説動画見る。
S <-> T 間の文字対応表をRとして作ってあげるという認識…であってる？
*/